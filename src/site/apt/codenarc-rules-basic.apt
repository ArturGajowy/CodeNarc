		--------------------------------------------------
					  CodeNarc - Basic Rules
		--------------------------------------------------

Basic Rules  ("<rulesets/basic.xml>")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* BigDecimalInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for calls to the <<<java.math.BigDecimal>>> constructors that take a <<<double>>> value as
  the first parameter. As described in the <<<BigDecimal>>> javadoc, the results from these constructors 
  can be somewhat unpredictable, and their use is generally not recommended. This is because some numbers,
  such as 0.1, cannot be represented exactly as a <<<double>>>.

  For instance, executing <<<println new BigDecimal(0.1)>>> prints out
  <<<0.1000000000000000055511151231257827021181583404541015625>>>.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def b1 = new BigDecimal(0.1)               // violation
    def b2 = new java.math.BigDecimal(23.45d)  // violation
-------------------------------------------------------------------------------


* BooleanInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for direct call to a <<<Boolean>>> constructor. Use <<<Boolean.valueOf()>>> or the <<<Boolean.TRUE>>>
  and <<<Boolean.FALSE>>> constants instead of calling the <<<Boolean()>>> constructor directly.

  Also checks for <<<Boolean.valueOf(true)>>> or <<<Boolean.valueOf(false)>>>. Use the <<<Boolean.TRUE>>>
  or <<<Boolean.FALSE>>> constants instead.

  Here is an example of code that produces a violation:
  
-------------------------------------------------------------------------------
    def b1 = new Boolean(true)             // violation
    def b2 = new java.lang.Boolean(false)  // violation
    def b3 = Boolean.valueOf(true)         // violation
    def b4 = Boolean.valueOf(false)        // violation
-------------------------------------------------------------------------------


* CloneableWithoutClone Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for classes that implement the <<<java.lang.Cloneable>>> interface without implementing
  the <<<clone()>>> method.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class BadClass implements Cloneable {
        def someMethod()
    }
-------------------------------------------------------------------------------


* ConstantIfExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for <if> statements with a constant value for the <if> boolean expression, such as
  <<<true>>>, <<<false>>>, <<<null>>>, or a literal constant value. These <if> statements
  can be simplified or avoided altogether. Examples of violations include:

-------------------------------------------------------------------------------
    if (true) { .. }
    if (false) { .. }
    if (Boolean.TRUE) { .. }
    if (Boolean.FALSE) { .. }
    if (null) { .. }
    if (0) { .. }
    if (99.7) { .. }
    if ("") { .. }
    if ("abc") { .. }
    if ([:]) { .. }
    if ([a:123, b:456]) { .. }
    if ([a, b, c]) { .. }
-------------------------------------------------------------------------------


* ConstantTernaryExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for ternary expressions with a constant value for the boolean expression, such as
 <<<true>>>, <<<false>>>, <<<null>>>, or a literal constant value. Examples of violations include:

-------------------------------------------------------------------------------
    true ? x : y
    false ? x : y
    Boolean.TRUE ? x : y
    Boolean.FALSE ? x : y
    null ? x : y
    0 ? x : y
    99.7 ? x : y
    "" ? x : y
    "abc" ? x : y
    [:] ? x : y
    [a:123, b:456] ? x : y
    [a, b, c] ? x : y
-------------------------------------------------------------------------------

 The rule also checks for the same types of constant values for the boolean expressions within the "short"
 ternary expressions, also known as the "Elvis" operator, e.g.:

-------------------------------------------------------------------------------
    true ?: y
    null ?: y
    99.7 ?: y
    "abc" ?: y
    [:] ?: y
    [a, b, c] ?: y
-------------------------------------------------------------------------------


* EmptyCatchBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <catch> blocks. In most cases, exceptions should not be caught and ignored (swallowed).

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        try {
            doSomething
        } catch(MyException e) {
            // should do something here
        }
    }
-------------------------------------------------------------------------------


* EmptyElseBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <else> blocks. Empty <else> blocks are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        if (x==23) {
            println 'ok'
        } else {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptyFinallyBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <finally> blocks. Empty <finally> blocks are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        try {
            doSomething()
        } finally {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptyForStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <for> blocks. Empty <for> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        for (int i=0; i < 23; i++) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptyIfStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <if> statements. Empty <if> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        if (x==23) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptySwitchStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <switch> statements. Empty <switch> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        switch(myVariable) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptySynchronizedStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <synchronized> statements. Empty <synchronized> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class MyClass {
        def myMethod() {
            synchronized(lock) {
            }
        }
    }
-------------------------------------------------------------------------------


* EmptyTryBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <try> blocks. Empty <try> blocks are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        try {
            // empty
        } catch(MyException e) {
            e.printStackTrace()
        }
    }
-------------------------------------------------------------------------------


* EmptyWhileStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <while> statements. Empty <while> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        while (!stopped) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EqualsAndHashCode Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks that if either the <<<boolean equals(Object)>>> or the <<<int hashCode()>>> methods
  are overridden within a class, then both must be overridden.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class MyClass {
        boolean equals(Object object) {
            // do something
        }
    }
-------------------------------------------------------------------------------

  And so does this:

-------------------------------------------------------------------------------
    class MyClass {
        int hashCode() {
            return 0
        }
    }
-------------------------------------------------------------------------------



* ReturnFromFinallyBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for a return from within a <finally> block. Returning from a <finally> block is confusing and 
  can hide the original exception.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    int myMethod() {
        try {
            doSomething()
            return 0
        } catch(Exception e) {
            return -1
        } finally {
            return 99               // violation
        }
    }
-------------------------------------------------------------------------------


* StringInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for direct call to the <<<String>>> constructor that accepts a <<<String>>> literal.
  In almost all cases, this is unnecessary. Use a <<<String>>> literal (e.g., "...") instead of calling the
  corresponding <<<String>>> constructor (<<<new String("..")>>>) directly.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def s = new String('abc')
-------------------------------------------------------------------------------


* ThrowExceptionFromFinallyBlock
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for throwing an exception from within a <finally> block. Throwing an exception from a
 <finally> block is confusing and can hide the original exception.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    int myMethod() {
        try {
            doSomething()
            throw new Exception()
        } finally {
            println 'finally'
            throw new Exception()   // violation
        }
    }
-------------------------------------------------------------------------------


* UnnecessaryBooleanExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for unnecessary boolean expressions, including ANDing (&&) or ORing (||) with
 <<<true>>>, <<<false>>>, <<<null>>>, or a Map/List/String/Number literal.

 This rule also checks for negation (!) of <<<true>>>, <<<false>>>,
 <<<null>>>, or a Map/List/String/Number literal.

 Examples of violations include:

-------------------------------------------------------------------------------

    result = value && true              // AND or OR with boolean constants
    if (false || value) { .. }
    return value && Boolean.FALSE

    result = null && value              // AND or OR with null

    result = value && "abc"             // AND or OR with String literal

    result = value && 123               // AND or OR with Number literal
    result = 678.123 || true

    result = value && [x, y]            // AND or OR with List literal

    result = [a:123] && value           // AND or OR with Map literal

    result = !true                      // Negation of boolean constants
    result = !false
    result = !Boolean.TRUE

    result = !null                      // Negation of null

    result = !"abc"                     // Negation of String literal

    result = ![a:123]                   // Negation of Map literal

    result = ![a,b]                     // Negation of List literal
-------------------------------------------------------------------------------


* UnnecessaryIfStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for <<if>> statements where the <if> and <else> blocks are merely returning
 <<<true>>> and <<<false>>> constants. These cases can be replaced by a simple return
 statement. Examples of violations include:

-------------------------------------------------------------------------------
    if (someExpression)         // can be replaced by: return someExpression
        return true
    else
        return false

    if (someExpression) {       // can be replaced by: return someExpression
        return true
    } else {
        return false
    }

    if (someExpression) {       // can be replaced by: return someExpression
        return Boolean.TRUE
    } else {
        return Boolean.FALSE
    }
-------------------------------------------------------------------------------


* UnnecessaryTernaryExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for ternary expressions where the conditional expression always evaluates to a boolean
 and the <true> and <false> expressions are merely returning <<<true>>> and <<<false>>> constants.
 These cases can be replaced by a simple boolean expression. Examples of violations include:

-------------------------------------------------------------------------------
    x==99 ? true : false                    // can be replaced by: x==99
    x && y ? true : false                   // can be replaced by: x && y
    x||y ? false : true                     // can be replaced by: !(x||y)
    x >= 1 ? true: false                    // can be replaced by: x >= 1
    x < 99 ? Boolean.TRUE : Boolean.FALSE   // can be replaced by: x < 99
    !x ? true : false                       // can be replaced by: !x
-------------------------------------------------------------------------------

 The rule also checks for ternary expressions where the <true> and <false> expressions are
 the same constant or variable. Examples include:

-------------------------------------------------------------------------------
    x ? '123' : '123'              // can be replaced by: '123'
    x ? null : null                // can be replaced by: null
    x ? 23 : 23                    // can be replaced by: 23
    x ? MAX_VALUE : MAX_VALUE      // can be replaced by: MAX_VALUE
    ready ? minValue : minValue    // can be replaced by: minValue
-------------------------------------------------------------------------------


