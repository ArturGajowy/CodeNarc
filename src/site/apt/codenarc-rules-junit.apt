		--------------------------------------------------
					  CodeNarc - JUnit Rules
		--------------------------------------------------

JUnit Rules  ("<rulesets/junit.xml>")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* JUnitAssertAlwaysFails Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Rule that checks for JUnit <<<assert()>>> method calls with constant arguments such that the
  assertion always fails. This includes: <<<assertTrue(false)>>>, <<<assertFalse(true)>>>
  and <<<assertNull(CONSTANT)>>>.

  This rule sets the default value of the <applyToClassNames> property to only match class names
  ending in 'Test', 'Tests' or 'TestCase'.


* JUnitAssertAlwaysSucceeds Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Rule that checks for JUnit <<<assert()>>> method calls with constant arguments such that the
  assertion always succeeds. This includes: <<<assertTrue(true)>>>, <<<assertFalse(false)>>>
  and <<<assertNull(null)>>>.

  This rule sets the default value of the <applyToClassNames> property to only match class names
  ending in 'Test', 'Tests' or 'TestCase'.


* JUnitPublicNonTestMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Rule that checks if a JUnit test class contains public methods other than standard test methods,
  JUnit framework methods or methods with JUnit annotations.

  The following public methods are ignored by this rule:

      * Zero-argument methods with names starting with "test"

      * The <<<setUp()>>> and <<<tearDown()>>> methods

      * Methods annotated with <<<@Test>>>

      * Methods annotated with <<<@Before>>> and <<<@After>>>

      * Methods annotated with <<<@BeforeClass>>> and <<<@AfterClass>>>

  Public, non-test methods on a test class violate conventional usage of test classes,
  and they typically break encapsulation unnecessarily.

  Public, non-test methods may also hide unintentional <'Lost Tests'>. For instance, the test method
  declaration may (unintentionally) include methods parameters, and thus be ignored by JUnit. Or the
  method may (unintentionally) not follow the "test.." naming convention and not have the @Test annotation,
  and thus be ignored by JUnit.

  This rule sets the default value of the <applyToClassNames> property to only match class names
  ending in 'Test', 'Tests' or 'TestCase'.


* JUnitSetUpCallsSuper Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Rule that checks that if the JUnit <<<setUp>>> method is defined, that it includes a call to
  <<<super.setUp()>>>.

  This rule sets the default value of the <applyToClassNames> property to only match class names
  ending in 'Test', 'Tests' or 'TestCase'.


* JUnitTearDownCallsSuper Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Rule that checks that if the JUnit <<<tearDown>>> method is defined, that it includes a call to
  <<<super.tearDown()>>>.

  This rule sets the default value of the <applyToClassNames> property to only match class names
  ending in 'Test', 'Tests' or 'TestCase'.


* JUnitUnnecessarySetUp Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Rule that checks checks for JUnit <<<setUp()>>> methods that contain only a call to
  <<<super.setUp()>>>. The method is then unnecessary.

  This rule sets the default value of the <applyToClassNames> property to only match class names
  ending in 'Test', 'Tests' or 'TestCase'.

  Here is an example of a violation:

-------------------------------------------------------------------------------
    class MyTest extends TestCase {
        void setUp() {              // violation
            super.setUp()
        }
    }
-------------------------------------------------------------------------------


* JUnitUnnecessaryTearDown Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Rule that checks checks for JUnit <<<tearDown()>>> methods that contain only a call to
  <<<super.tearDown()>>>. The method is then unnecessary.

  This rule sets the default value of the <applyToClassNames> property to only match class names
  ending in 'Test', 'Tests' or 'TestCase'.

  Here is an example of a violation:

-------------------------------------------------------------------------------
    class MyTest extends TestCase {
        void tearDown() {               // violation
            super.tearDown()
        }
    }
-------------------------------------------------------------------------------

* UseAssertEqualsInsteadOfAssertTrue Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects JUnit assertions in object equality. These assertions should be made by more specific methods, like
  assertEquals.

* UseAssertTrueInsteadOfAssertEqualsRule Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects JUnit calling assertEquals where the first parameter is a boolean. These assertions should be made
  by more specific methods, like assertTrue or assertFalse.

* UseAssertNullInsteadOfAssertEquals
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects JUnit calling assertEquals where the first or second parameter is null. These assertion should be 
  made against the assertNull method instead.

* UseAssertSameInsteadOfAssertTrue Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects JUnit calling assertTrue or assertFalse where the first or second parameter is an Object#is() call testing for
  reference equality. These assertion should be made against the assertSame or assertNotSame method instead.

* UseFailWithMessageInsteadOfWithout Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects JUnit calling the fail() method without an argument. For better error reporting you should always
  provide a message.

