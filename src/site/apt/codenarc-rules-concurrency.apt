		--------------------------------------------------
					  CodeNarc - Concurrency Rules
		--------------------------------------------------

Concurrency Rules  ("<rulesets/concurrency.xml>")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* AvoidThreadGroup Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.13
  Avoid using ThreadGroup; although it is intended to be used in a threaded environment it contains methods
  that are not thread safe.

  Here is an example of code that produces a violation:
-------------------------------------------------------------------------------
    new ThreadGroup("...")
    new ThreadGroup(tg, "my thread group")
    Thread.currentThread().getThreadGroup()
    System.getSecurityManager().getThreadGroup()
-------------------------------------------------------------------------------


* InconsistentPropertySynchronization Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <New in CodeNarc 0.13>
  Class contains similarly-named get and set methods where the set method is synchronized and the get method is not,
  or the get method is synchronized and the set method is not. This may result in incorrect behavior at runtime, as
  callers of the get and set methods will not necessarily see a consistent state for the object. The get and set method
  should both be synchronized or neither should be synchronized.

  Example of violations:
-------------------------------------------------------------------------------
    class Person {
        String name
        Date birthday
        boolean deceased
        boolean parent

        synchronized setName(String name) {
            this.name = name
        }
        // violation, get method should be synchronized
        String getName() {
            name
        }

        // violation, set method should be synchronized
        void setBirthday(Date birthday) {
            this.birthday = birthday
        }

        synchronized String getBirthday() {
            birthday
        }

        // violation, set method should be synchronized
        void setDeceased(boolean deceased) {
            this.deceased = deceased
        }

        synchronized boolean isDeceased() {
            deceased
        }

        synchronized void setParent(boolean parent) {
            this.parent = parent
        }

        // violation, get method should be synchronized
        boolean isParent() {
            parent
        }
    }
-------------------------------------------------------------------------------

* NestedSynchronization Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  This rule reports occurrences of nested <<<synchronized>>> statements.

  Nested <<<synchronized>>> statements should be avoided. Nested <<<synchronized>>> statements
  are either useless (if the lock objects are identical) or prone to deadlock.

  Note that a <closure> or an <anonymous inner class> carries its own context (scope).
  A <<<synchronized>>> statement within a <closure> or an <anonymous inner class> defined
  within an outer <<<synchronized>>> statement does not cause a violation (though nested
  <<<synchronized>>> statements within either of those will). 

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
                def myMethod() {
                    synchronized(this) {
                        // do something ...
                        synchronized(this) {
                            // do something else ...
                        }
                    }
                }
-------------------------------------------------------------------------------


* StaticCalendarField Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <New in CodeNarc 0.13>
  Calendar objects should not be used as static fields. Calendars are inherently unsafe for multithreaded use. Sharing a
  single instance across thread boundaries without proper synchronization will result in erratic behavior of the application.
  Under 1.4 problems seem to surface less often than under Java 5 where you will probably see random ArrayIndexOutOfBoundsExceptions
  or IndexOutOfBoundsExceptions in sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate(). You may also experience
  serialization problems. Using an instance field or a ThreadLocal is recommended.

  For more information on this see Sun Bug #6231579 and Sun Bug #6178997.

  Examples:
-------------------------------------------------------------------------------
  // two violations
  class MyClass {
    static Calendar calendar1
    static java.util.Calendar calendar2
  }

  // these usages are OK
  class MyCorrectClass {
    private final Calendar calendar1
    static ThreadLocal<Calendar> calendar2
  }
-------------------------------------------------------------------------------


* StaticDateFormatField Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <New in CodeNarc 0.13>
  DateFormat objects should not be used as static fields. DateFormat are inherently unsafe for multithreaded use. Sharing a
  single instance across thread boundaries without proper synchronization will result in erratic behavior of the application.
  Under 1.4 problems seem to surface less often than under Java 5 where you will probably see random ArrayIndexOutOfBoundsExceptions
  or IndexOutOfBoundsExceptions in sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate(). You may also experience
  serialization problems. Using an instance field or a ThreadLocal is recommended.

  For more information on this see Sun Bug #6231579 and Sun Bug #6178997.

  Examples:
-------------------------------------------------------------------------------
  // two violations
  class MyClass {
    static DateFormat dateFormat1
    static java.text.DateFormat dateFormat2
  }

  // these usages are OK
  class MyCorrectClass {
    private DateFormat calendar1
    static ThreadLocal<DateFormat> calendar2
  }
-------------------------------------------------------------------------------

* SynchronizedMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 This rule reports uses of the <<<synchronized>>> keyword on methods. Synchronized methods
 are the same as synchronizing on 'this', which effectively make your synchronization policy
 public and modifiable by other objects. To avoid possibilities of deadlock, it is better to
 synchronize on internal objects.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    synchronized def myMethod() {
        // do stuff ...
    }
-------------------------------------------------------------------------------


* SynchronizedOnGetClass Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  Checks for synchronization on <<<getClass()>>> rather than class literal. This instance method
  synchronizes on <<<this.getClass()>>>. If this class is subclassed, subclasses will synchronize
  on the class object for the subclass, which isn't likely what was intended.


* SynchronizedOnBoolean Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <New in CodeNarc 0.13>
  Synchronization on a Boolean field can lead to deadlock because Boolean are cached by the JVM and can be shared.
  Since there normally exist only two Boolean objects, this code could be synchronizing on the same object as other,
  unrelated code, leading to unresponsiveness and possible deadlock
  Examples:
-------------------------------------------------------------------------------
    class MyClass {

        final String lock = false

        def method() {
            // violation
            synchronized(lock) { }
        }
    }

    class MyClass {

        final String lock = false

        class MyInnerClass {
            def method() {
                // violation
                synchronized(lock) { }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = true

        def method() {
            // violation
            synchronized(lock) { }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        def method() {
            return new Runnable() {
                final def lock = false // shadows parent from inner class
                public void run() {
                    // violation
                    synchronized(stringLock) { }
                }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        class MyInnerClass {

            final def lock = true // shadows parent from inner class
            def method() {
                // violation
                synchronized(stringLock) { }
            }
        }
    }
-------------------------------------------------------------------------------


* SynchronizedOnString Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <New in CodeNarc 0.13>
  Synchronization on a String field can lead to deadlock. Constant Strings are interned and shared across all other
  classes loaded by the JVM. Thus, this could is locking on something that other code might also be locking. This could
  result in very strange and hard to diagnose blocking and deadlock behavior.

  See http://www.javalobby.org/java/forums/t96352.html and http://jira.codehaus.org/browse/JETTY-352.

  Examples:
-------------------------------------------------------------------------------
    class MyClass {

        final String stringLock = "stringLock"

        def method() {
            // violation
            synchronized(stringLock) { }
        }
    }

    class MyClass {

        final String stringLock = "stringLock"

        class MyInnerClass {
            def method() {
                synchronized(stringLock) { }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def stringLock = "stringLock"

        def method() {
            // violation
            synchronized(stringLock) { }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        def method() {
            return new Runnable() {
                final def lock = "" // shadows parent from inner class
                public void run() {
                    // violation
                    synchronized(stringLock) { }
                }
            }
        }
    }

    class MyClass {
        // implicit typing
        final def lock = new Object[0] // correct idiom

        class MyInnerClass {

            final def lock = "" // shadows parent from inner class
            def method() {
                // violation
                synchronized(stringLock) { }
            }
        }
    }
-------------------------------------------------------------------------------

* SynchronizedOnThis Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  This rule reports uses of the <<<synchronized>>> blocks where the synchronization reference
  is 'this'. Doing this effectively makes your synchronization policy public and modifiable
  by other objects. To avoid possibilities of deadlock, it is better to synchronize on internal objects.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def method3() {
        synchronized(this) {
            // do stuff ...
        }
    }
-------------------------------------------------------------------------------


* SynchronizedReadObjectMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <New in CodeNarc 0.13>
  Catches Serializable classes that define a synchronized readObject method. By definition, an object created by
  deserialization is only reachable by one thread, and thus there is no need for readObject() to be synchronized. If
  the readObject() method itself is causing the object to become visible to another thread, that is an example of very
  dubious coding style.

  Examples:
-------------------------------------------------------------------------------
    class MyClass implements Serializable {

        private synchronized void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
            // violation, no need to synchronized
        }
    }

    class MyClass implements Serializable {

        private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
            synchronized(lock) {
                // violation, no need to synchronized
            }
        }
    }

    // OK, class not Serializable
    class MyClass {

        private synchronized void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException { }
    }

    // OK, class not Serializable
    class MyClass {

        private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
            synchronized(lock) { }
        }
    }

    class MyClass implements Serializable {

        private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
            // OK, this block is more than just a simple sync statement
            synchronized(lock) { }
            doSomething()
        }
    }


-------------------------------------------------------------------------------

* SystemRunFinalizersOnExit Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  This rule reports uses of the <<<System.runFinalizersOnExit()>>> method. 

  Method calls to <<<System.runFinalizersOnExit()>>> should not be allowed. This method is inherently
  non-thread-safe, may result in data corruption, deadlock, and may affect parts of the program
  far removed from it's call point. It is deprecated, and it's use strongly discouraged.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def method() {
        System.runFinalizersOnExit(true)
    }
-------------------------------------------------------------------------------


* ThreadLocalNotStaticFinal Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  This rule reports definition of the <<<ThreadLocal>>> fields that are not <<<static>>> and <<<final>>>.

  <ThreadLocal> fields should be <<<static>>> and <<<final>>>. In the most common case a
  <<<java.lang.ThreadLocal>>> instance associates state with a thread. A non-<<<static>>>
  non-<<<final>>> <<<java.lang.ThreadLocal>>> field associates state with an instance-thread combination.
  This is seldom necessary and often a bug which can cause memory leaks and possibly incorrect behavior.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    private static ThreadLocal local1 = new ThreadLocal()
    private final ThreadLocal local2 = new ThreadLocal()
    protected ThreadLocal local3 = new ThreadLocal()
    ThreadLocal local4 = new ThreadLocal()
-------------------------------------------------------------------------------


* ThreadYield Rule
~~~~~~~~~~~~~~~~~~~

  This rule reports uses of the <<<Thread.yield()>>> method.

  Method calls to <<<Thread.yield()>>> should not be allowed. This method has no useful guaranteed 
  semantics, and is often used by inexperienced programmers to mask race conditions.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
     def method() {
         Thread.yield()
     }
-------------------------------------------------------------------------------


* VolatileLongOrDoubleField Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  This rule reports on <<<long>>> or <<<double>>> fields that are declared <<<volatile>>>.

  Long or double fields should not be declared as <<<volatile>>>. Java specifies that reads and
  writes from such fields are atomic, but many JVM's have violated this specification. Unless you
  are certain of your JVM, it is better to synchronize access to such fields rather than declare
  them <<<volatile>>>. This rule flags fields marked <<<volatile>>> when their type is <<<double>>> 
  or <<<long>>> or the name of their type is "Double" or "Long".

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
     def method() {
         private volatile double d
         private volatile long f
     }
-------------------------------------------------------------------------------


* UseOfNotifyMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>
  
  Checks for code that calls <<<notify()>>> rather than <<<notifyAll()>>>. Java monitors are often used
  for multiple conditions. Calling <<<notify()>>> only wakes up one thread, meaning that the awakened
  thread might not be the one waiting for the condition that the caller just satisfied.

  Also see {{{http://www.javaconcurrencyinpractice.com/}<<Java_Concurrency_in_Practice>>}}, Brian Goetz, p 303.
