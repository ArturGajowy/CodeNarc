		--------------------------------------------------
					  CodeNarc - Basic Rules
		--------------------------------------------------

Basic Rules  ("<rulesets/basic.xml>")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* BigDecimalInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for calls to the <<<java.math.BigDecimal>>> constructors that take a <<<double>>> value as
  the first parameter. As described in the <<<BigDecimal>>> javadoc, the results from these constructors 
  can be somewhat unpredictable, and their use is generally not recommended. This is because some numbers,
  such as 0.1, cannot be represented exactly as a <<<double>>>.

  For instance, executing <<<println new BigDecimal(0.1)>>> prints out
  <<<0.1000000000000000055511151231257827021181583404541015625>>>.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def b1 = new BigDecimal(0.1)               // violation
    def b2 = new java.math.BigDecimal(23.45d)  // violation
-------------------------------------------------------------------------------


* BooleanMethodReturnsNull Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Checks for a method with <<<Boolean>>> return type that returns an explicit <<<null>>>. A method that
  returns either <<<Boolean.TRUE>>>, <<<Boolean.FALSE>>> or <<<null>>> is an accident waiting to happen.
  This method can be invoked as though it returned a value of type <<<boolean>>>, and the compiler will
  insert automatic <unboxing> of the <<<Boolean>>> value. If a <<<null>>> value is returned, this will
  result in a <<<NullPointerException>>>.


* BooleanInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for direct call to a <<<Boolean>>> constructor. Use <<<Boolean.valueOf()>>> or the <<<Boolean.TRUE>>>
  and <<<Boolean.FALSE>>> constants instead of calling the <<<Boolean()>>> constructor directly.

  Also checks for <<<Boolean.valueOf(true)>>> or <<<Boolean.valueOf(false)>>>. Use the <<<Boolean.TRUE>>>
  or <<<Boolean.FALSE>>> constants instead.

  Here is an example of code that produces a violation:
  
-------------------------------------------------------------------------------
    def b1 = new Boolean(true)             // violation
    def b2 = new java.lang.Boolean(false)  // violation
    def b3 = Boolean.valueOf(true)         // violation
    def b4 = Boolean.valueOf(false)        // violation
-------------------------------------------------------------------------------


* CloneableWithoutClone Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for classes that implement the <<<java.lang.Cloneable>>> interface without implementing
  the <<<clone()>>> method.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class BadClass implements Cloneable {
        def someMethod()
    }
-------------------------------------------------------------------------------


* ConstantIfExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for <if> statements with a constant value for the <if> boolean expression, such as
  <<<true>>>, <<<false>>>, <<<null>>>, or a literal constant value. These <if> statements
  can be simplified or avoided altogether. Examples of violations include:

-------------------------------------------------------------------------------
    if (true) { .. }
    if (false) { .. }
    if (Boolean.TRUE) { .. }
    if (Boolean.FALSE) { .. }
    if (null) { .. }
    if (0) { .. }
    if (99.7) { .. }
    if ("") { .. }
    if ("abc") { .. }
    if ([:]) { .. }
    if ([a:123, b:456]) { .. }
    if ([a, b, c]) { .. }
-------------------------------------------------------------------------------


* ConstantTernaryExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for ternary expressions with a constant value for the boolean expression, such as
 <<<true>>>, <<<false>>>, <<<null>>>, or a literal constant value. Examples of violations include:

-------------------------------------------------------------------------------
    true ? x : y
    false ? x : y
    Boolean.TRUE ? x : y
    Boolean.FALSE ? x : y
    null ? x : y
    0 ? x : y
    99.7 ? x : y
    "" ? x : y
    "abc" ? x : y
    [:] ? x : y
    [a:123, b:456] ? x : y
    [a, b, c] ? x : y
-------------------------------------------------------------------------------

 The rule also checks for the same types of constant values for the boolean expressions within the "short"
 ternary expressions, also known as the "Elvis" operator, e.g.:

-------------------------------------------------------------------------------
    true ?: y
    null ?: y
    99.7 ?: y
    "abc" ?: y
    [:] ?: y
    [a, b, c] ?: y
-------------------------------------------------------------------------------


* DuplicateSwitchStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Check for duplicate <<<case>>> statements in a <<<switch>>> block, such as two equal
  integers or strings. Here are some examples of code that produces violations:

-------------------------------------------------------------------------------
            switch( 0 ) {
                case 1: break;
                case 2: break;
                case 2: break;          // violation
            }

            switch( "test" ) {
                case "$a": break;
                case "$a": break;       // ok; only flags constant values (not GStrings)
                case "ab": break;
                case "ab": break;       // violation
                case "abc": break;
            }
-------------------------------------------------------------------------------


* EmptyCatchBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <catch> blocks. In most cases, exceptions should not be caught and ignored (swallowed).

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        try {
            doSomething
        } catch(MyException e) {
            // should do something here
        }
    }
-------------------------------------------------------------------------------


* EmptyElseBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <else> blocks. Empty <else> blocks are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        if (x==23) {
            println 'ok'
        } else {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptyFinallyBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <finally> blocks. Empty <finally> blocks are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        try {
            doSomething()
        } finally {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptyForStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <for> blocks. Empty <for> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        for (int i=0; i < 23; i++) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptyIfStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <if> statements. Empty <if> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        if (x==23) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptySwitchStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <switch> statements. Empty <switch> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        switch(myVariable) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptySynchronizedStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <synchronized> statements. Empty <synchronized> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class MyClass {
        def myMethod() {
            synchronized(lock) {
            }
        }
    }
-------------------------------------------------------------------------------


* EmptyTryBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <try> blocks. Empty <try> blocks are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        try {
            // empty
        } catch(MyException e) {
            e.printStackTrace()
        }
    }
-------------------------------------------------------------------------------


* EmptyWhileStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <while> statements. Empty <while> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        while (!stopped) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EqualsAndHashCode Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks that if either the <<<boolean equals(Object)>>> or the <<<int hashCode()>>> methods
  are overridden within a class, then both must be overridden.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class MyClass {
        boolean equals(Object object) {
            // do something
        }
    }
-------------------------------------------------------------------------------

  And so does this:

-------------------------------------------------------------------------------
    class MyClass {
        int hashCode() {
            return 0
        }
    }
-------------------------------------------------------------------------------


* GStringAsMapKey Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  A GString should not be used as a map key since its <hashcode> is not guaranteed to be stable.
  Consider calling <<<key.toString()>>>.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    Map map = ["${someRef}" : 'invalid' ]       // violation
-------------------------------------------------------------------------------


* RemoveAllOnSelf Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Don't use <<<removeAll>>> to clear a collection. If you want to remove all elements from a
  collection <<<c>>>, use <<<c.clear>>>, not <<<c.removeAll(c)>>>. Calling <<<c.removeAll(c)>>>
  to clear a collection is less clear, susceptible to errors from typos, less efficient and
  for some collections, might throw a <<<ConcurrentModificationException>>>.


* ReturnFromFinallyBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for a return from within a <finally> block. Returning from a <finally> block is confusing and 
  can hide the original exception.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    int myMethod() {
        try {
            doSomething()
            return 0
        } catch(Exception e) {
            return -1
        } finally {
            return 99               // violation
        }
    }
-------------------------------------------------------------------------------


* ReturnsNullInsteadOfEmptyArray Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  If you have a method or closure that returns an array, then when there are no results return a zero-length
  (empty) array rather than <<<null>>>. It is often a better design to return a zero-length array rather than a
  <<<null>>> reference to indicate that there are no results (i.e., an <empty> list of results). This way,
  no explicit check for <<<null>>> is needed by clients of the method.


* ReturnsNullInsteadOfEmptyCollection Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  If you have a method or closure that returns a collection, then when there are no results return a zero-length
  (empty) collection rather than <<<null>>>. It is often a better design to return a zero-length collection
  rather than a <<<null>>> reference to indicate that there are no results (i.e., an <empty> list of results).
  This way, no explicit check for <<<null>>> is needed by clients of the method.


* SerialVersionUID Rule
~~~~~~~~~~~~~~~~~~~~~~~~

  A <<serialVersionUID>> is normally intended to be used with Serialization. It needs to be of type
  <<<long>>>, <<<static>>>, and <<<final>>>. Also, it should have a <visibility modifier> such
  as <<<public>>> or <<<private>>>. Providing no modifier creates a <Property> and Groovy generates
  a <getter>, which is probably not intended.


* StringInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for direct call to the <<<String>>> constructor that accepts a <<<String>>> literal.
  In almost all cases, this is unnecessary. Use a <<<String>>> literal (e.g., "...") instead of calling the
  corresponding <<<String>>> constructor (<<<new String("..")>>>) directly.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def s = new String('abc')
-------------------------------------------------------------------------------


* ThrowExceptionFromFinallyBlock
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for throwing an exception from within a <finally> block. Throwing an exception from a
 <finally> block is confusing and can hide the original exception.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    int myMethod() {
        try {
            doSomething()
            throw new Exception()
        } finally {
            println 'finally'
            throw new Exception()   // violation
        }
    }
-------------------------------------------------------------------------------


* UnnecessaryBooleanExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for unnecessary boolean expressions, including ANDing (&&) or ORing (||) with
 <<<true>>>, <<<false>>>, <<<null>>>, or a Map/List/String/Number literal.

 This rule also checks for negation (!) of <<<true>>>, <<<false>>>,
 <<<null>>>, or a Map/List/String/Number literal.

 Examples of violations include:

-------------------------------------------------------------------------------

    result = value && true              // AND or OR with boolean constants
    if (false || value) { .. }
    return value && Boolean.FALSE

    result = null && value              // AND or OR with null

    result = value && "abc"             // AND or OR with String literal

    result = value && 123               // AND or OR with Number literal
    result = 678.123 || true

    result = value && [x, y]            // AND or OR with List literal

    result = [a:123] && value           // AND or OR with Map literal

    result = !true                      // Negation of boolean constants
    result = !false
    result = !Boolean.TRUE

    result = !null                      // Negation of null

    result = !"abc"                     // Negation of String literal

    result = ![a:123]                   // Negation of Map literal

    result = ![a,b]                     // Negation of List literal
-------------------------------------------------------------------------------


* UnnecessaryConstructor Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when a constructor is not necessary; i.e., when there's only one constructor, it's
  <<<public>>>, has an empty body, and takes no arguments.


* UnnecessaryIfStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for <<if>> statements where the <if> and <else> blocks are merely returning
 <<<true>>> and <<<false>>> constants. These cases can be replaced by a simple return
 statement. Examples of violations include:

-------------------------------------------------------------------------------
    if (someExpression)         // can be replaced by: return someExpression
        return true
    else
        return false

    if (someExpression) {       // can be replaced by: return someExpression
        return true
    } else {
        return false
    }

    if (someExpression) {       // can be replaced by: return someExpression
        return Boolean.TRUE
    } else {
        return Boolean.FALSE
    }
-------------------------------------------------------------------------------


* UnnecessaryTernaryExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for ternary expressions where the conditional expression always evaluates to a boolean
 and the <true> and <false> expressions are merely returning <<<true>>> and <<<false>>> constants.
 These cases can be replaced by a simple boolean expression. Examples of violations include:

-------------------------------------------------------------------------------
    x==99 ? true : false                    // can be replaced by: x==99
    x && y ? true : false                   // can be replaced by: x && y
    x||y ? false : true                     // can be replaced by: !(x||y)
    x >= 1 ? true: false                    // can be replaced by: x >= 1
    x < 99 ? Boolean.TRUE : Boolean.FALSE   // can be replaced by: x < 99
    !x ? true : false                       // can be replaced by: !x
-------------------------------------------------------------------------------

 The rule also checks for ternary expressions where the <true> and <false> expressions are
 the same constant or variable. Examples include:

-------------------------------------------------------------------------------
    x ? '123' : '123'              // can be replaced by: '123'
    x ? null : null                // can be replaced by: null
    x ? 23 : 23                    // can be replaced by: 23
    x ? MAX_VALUE : MAX_VALUE      // can be replaced by: MAX_VALUE
    ready ? minValue : minValue    // can be replaced by: minValue
-------------------------------------------------------------------------------

* UselessCollectionCall Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Checks for useless calls to collections. For any collection <<<c>>>, calling <<<c.containsAll(c)>>>
  should always be <<<true>>>, and <<<c.retainAll(c)>>> should have no effect.


* UselessOverridingMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Checks for an overriding method that merely calls the same method defined in a superclass. Remove it. 

* ExplicitCallToPlusMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the plus(Object) method is called directly in code instead of using the + operator. A groovier
  way to express this: a.plus(b) is this: a + b


* ExplicitCallToMinusMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the minus(Object) method is called directly in code instead of using the - operator. A groovier
  way to express this: a.minus(b) is this: a - b


* ExplicitCallToMultiplyMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the multiply(Object) method is called directly in code instead of using the * operator. A groovier
  way to express this: a.multiply(b) is this: a * b


* ExplicitCallToDivMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the div(Object) method is called directly in code instead of using the / operator. A groovier
  way to express this: a.div(b) is this: a / b


* ExplicitCallToPowerMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the power(Object) method is called directly in code instead of using the ** operator. A groovier
  way to express this: a.power(b) is this: a ** b


* ExplicitCallToModMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the mod(Object) method is called directly in code instead of using the % operator. A groovier
  way to express this: a.mod(b) is this: a % b


* ExplicitCallToOrMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the or(Object) method is called directly in code instead of using the | operator. A groovier
  way to express this: a.or(b) is this: a | b


* ExplicitCallToAndMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the and(Object) method is called directly in code instead of using the & operator. A groovier
  way to express this: a.and(b) is this: a & b


* ExplicitCallToXorMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the xor(Object) method is called directly in code instead of using the ^ operator. A groovier
  way to express this: a.xor(b) is this: a ^ b


* ExplicitCallToGetAtMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the getAt(Object) method is called directly in code instead of using the [] index operator.
  A groovier way to express this: a.getAt(b) is this: a[b]


* ExplicitCallToLeftShiftMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the leftShift(Object) method is called directly in code instead of using the << operator.
  A groovier way to express this: a.leftShift(b) is this: a << b


* ExplicitCallToRightShiftMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the rightShift(Object) method is called directly in code instead of using the >> operator.
  A groovier way to express this: a.rightShift(b) is this: a >> b


* ExplicitCallToCompareToMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the compareTo(Object) method is called directly in code instead of using the <=>, >, >=, <,
  and <= operators. A groovier way to express this: a.compareTo(b) is this: a <=> b, or using the other operators. Here
  are some other ways to write groovier code: 
-------------------------------------------------------------------------------
    a.compareTo(b) == 0               // can be replaced by: a == b
    a.compareTo(b)                    // can be replaced by: a <=> b
    a.compareTo(b) > 0                // can be replaced by: a > b
    a.compareTo(b) >= 0               // can be replaced by: a >= b
    a.compareTo(b) < 0                // can be replaced by: a < b
    a.compareTo(b) <= 0               // can be replaced by: a <= b
-------------------------------------------------------------------------------


* ExplicitCallToEqualsMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule detects when the equals(Object) method is called directly in code instead of using the == or != operator.
  A groovier way to express this: a.equals(b) is this: a == b and a groovier way to express : !a.equals(b) is : a != b

* ExplicitCreationOfArrayList Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule checks for the explicit instantiation of an ArrayList. In Groovy, it is best to write "new ArrayList()"
  as "[]", which creates the same object.


* ExplicitCreationOfHashMap Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule checks for the explicit instantiation of a HashMap. In Groovy, it is best to write "new HashMap()" as
  "[:]", which creates the same object.


* ExplicitCreationOfHashSet Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule checks for the explicit instantiation of a HashSet. In Groovy, it is best to write "new HashSet()" as
  "[] as Set", which creates the same object.


* ExplicitCreationOfTreeSet Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule checks for the explicit instantiation of a TreeSet. In Groovy, it is best to write "new TreeSet()" as
  "[] as SortedSet", which creates the same object.


* ExplicitCreationOfLinkedList Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule checks for the explicit instantiation of a LinkedList. In Groovy, it is best to write "new LinkedList()"
  as "[] as Queue", which creates the same object.


* ExplicitCreationOfStack Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  This rule checks for the explicit instantiation of a Stack. In Groovy, it is best to write "new Stack()" as "[] as
  Stack", which creates the same object.

