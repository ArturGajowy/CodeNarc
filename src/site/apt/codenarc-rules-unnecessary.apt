		--------------------------------------------------
					  CodeNarc - Unnecessary Rules
		--------------------------------------------------

Unnecessary Rules  ("<rulesets/unnecessary.xml>")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


* UnnecessaryBigDecimalInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  It is unnecessary to instantiate BigDecimal objects. Instead just use the decimal literal or the 'G' identifier to force the type, such as 123.45 or 123.45G.


* UnnecessaryBigIntegerInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  It is unnecessary to instantiate BigInteger objects. Instead just use the literal with the 'G' identifier to force the type, such as 8G or 42G.


* UnnecessaryBooleanExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for unnecessary boolean expressions, including ANDing (&&) or ORing (||) with
 <<<true>>>, <<<false>>>, <<<null>>>, or a Map/List/String/Number literal.

 This rule also checks for negation (!) of <<<true>>>, <<<false>>>,
 <<<null>>>, or a Map/List/String/Number literal.

 Examples of violations include:

-------------------------------------------------------------------------------

    result = value && true              // AND or OR with boolean constants
    if (false || value) { .. }
    return value && Boolean.FALSE

    result = null && value              // AND or OR with null

    result = value && "abc"             // AND or OR with String literal

    result = value && 123               // AND or OR with Number literal
    result = 678.123 || true

    result = value && [x, y]            // AND or OR with List literal

    result = [a:123] && value           // AND or OR with Map literal

    result = !true                      // Negation of boolean constants
    result = !false
    result = !Boolean.TRUE

    result = !null                      // Negation of null

    result = !"abc"                     // Negation of String literal

    result = ![a:123]                   // Negation of Map literal

    result = ![a,b]                     // Negation of List literal
-------------------------------------------------------------------------------

* UnnecessaryCallForLastElement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  This rule checks for excessively verbose methods of accessing the last element of an array or list. For instance, it
  is possible to access the last element of an array by performing array[array.length - 1], in Groovy it is simpler to
  either call array.last() or array[-1]. The same is true for lists. This violation is triggered whenever a get, getAt,
  or array-style access is used with an object size check.

  Code like this all cause violations.
  -------------------------------------------------------------------------------
    def x = [0, 1, 2]
    def a = x.get(x.size() -1)
    def b = x.get(x.length -1)
    def c = x.getAt(x.size() -1)
    def d = x.getAt(x.length -1)
    def f = x[(x.size() -1]
    def d = x[(x.length -1]
  -------------------------------------------------------------------------------

  All of this code is fine though:
  -------------------------------------------------------------------------------
    def x = [0, 1, 2]
    def a = x.last()
    def b = x[-1]
    def c = x.getAt(-1)
    def d = x.get(z.size() -1)     // different objects
    def e = x.get(z.length -1)     // different objects
    def f = x.getAt(z.size() -1)   // different objects
  -------------------------------------------------------------------------------

* UnnecessaryCatchBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  Violations are triggered when a catch block does nothing but throw the original exception. In this scenario
  there is usually no need for a catch block, just let the exception be thrown from the original code. This
  condition frequently occurs when catching an exception for debugging purposes but then forgetting to take the
  catch statement out. 

* UnnecessaryCollectCall Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  Some method calls to Object.collect(Closure) can be replaced with the spread operator. For instance,
  list.collect { it.multiply(2) } can be replaced by list*.multiply(2).

 Examples of violations include:

-------------------------------------------------------------------------------

    assert [1, 2, 3].collect { it.multiply(2) }
    assert [1, 2, 3].collect { x -> x.multiply(2) }
    ["1", "2", "3"].collect { it.bytes }

 The following code does not produce violations:

-------------------------------------------------------------------------------
    [1, 2, 3].collect { it * it }   // OK, closure parameter is referenced twice

    [1, 2, 3].mapMethod { it.multiply(5) } // OK, method call is not collect

    [1, 2, 3].collect(5) // OK, collect parameter is not a closure

    // OK, the closure is not a simple one line statement
    [1, 2, 3].collect { println it; it.multiply(5) }

    // OK, closure has too many arguments
    [1, 2, 3].collect { a, b -> a.multiply(b) }

    // OK, closure statement references parameter multiple times
    [1, 2, 3].collect { it.multiply(it) }

    // OK, it is referenced several times in the closure
    [1, 2, 3].collect { it.multiply(2).multiply(it) }
    ["1", "2", "3"].collect { it.bytes.foo(it) }

    // OK, chained methods are too complex to analyze at this point
    [1, 2, 3].collect { it.multiply(2).multiply(4) }

    // in general the above examples can be rewritten like this: 
    [1, 2, 3]*.multiply(2)
    ["1", "2", "3"]*.bytes


* UnnecessaryConstructor Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when a constructor is not necessary; i.e., when there's only one constructor, it's
  <<<public>>>, has an empty body, and takes no arguments.


* UnnecessaryDoubleInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  It is unnecessary to instantiate Double objects. Instead just use the double literal with 'D' identifier to force the type, such as 123.45d or 0.42d.


* UnnecessaryFloatInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  It is unnecessary to instantiate Float objects. Instead just use the float literal with the 'F' identifier to force the type, such as 123.45F or 0.42f.


* UnnecessaryIfStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for <<if>> statements where the <if> and <else> blocks are merely returning
 <<<true>>> and <<<false>>> constants. These cases can be replaced by a simple return
 statement. Examples of violations include:

-------------------------------------------------------------------------------
    if (someExpression)         // can be replaced by: return someExpression
        return true
    else
        return false

    if (someExpression) {       // can be replaced by: return someExpression
        return true
    } else {
        return false
    }

    if (someExpression) {       // can be replaced by: return someExpression
        return Boolean.TRUE
    } else {
        return Boolean.FALSE
    }

    if (someExpression)         // (implicit return) can be replaced by: someExpression
        true                    // And if this is NOT the last statement in a block, then it is totally unnecessary
    else false
-------------------------------------------------------------------------------


* UnnecessaryTernaryExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for ternary expressions where the conditional expression always evaluates to a boolean
 and the <true> and <false> expressions are merely returning <<<true>>> and <<<false>>> constants.
 These cases can be replaced by a simple boolean expression. Examples of violations include:

-------------------------------------------------------------------------------
    x==99 ? true : false                    // can be replaced by: x==99
    x && y ? true : false                   // can be replaced by: x && y
    x||y ? false : true                     // can be replaced by: !(x||y)
    x >= 1 ? true: false                    // can be replaced by: x >= 1
    x < 99 ? Boolean.TRUE : Boolean.FALSE   // can be replaced by: x < 99
    !x ? true : false                       // can be replaced by: !x
-------------------------------------------------------------------------------

 The rule also checks for ternary expressions where the <true> and <false> expressions are
 the same constant or variable. Examples include:

-------------------------------------------------------------------------------
    x ? '123' : '123'              // can be replaced by: '123'
    x ? null : null                // can be replaced by: null
    x ? 23 : 23                    // can be replaced by: 23
    x ? MAX_VALUE : MAX_VALUE      // can be replaced by: MAX_VALUE
    ready ? minValue : minValue    // can be replaced by: minValue
-------------------------------------------------------------------------------


* UnnecessaryCollectionCall Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  Checks for useless calls to collections. For any collection <<<c>>>, calling <<<c.containsAll(c)>>>
  should always be <<<true>>>, and <<<c.retainAll(c)>>> should have no effect.


* UnnecessaryGetter Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  Checks for explicit calls to getter/accessor methods which can, for the most part, be replaced by property access.
  A getter is defined as a method call that matches get[A-Z] but not getClass() or get[A-Z][A-Z] such as getURL().
  Getters do not take method arguments.

  These bits of code produce violations:

-------------------------------------------------------------------------------
    x.getProperty()
    x.getFirst()
    x.getFirstName()
    x.getA()
-------------------------------------------------------------------------------

  These bits of code do not:

-------------------------------------------------------------------------------
    x.property
    x.first
    x.firstName
    x.a
    x.getURL()
    x.getClass()
    x.getProperty('key')
-------------------------------------------------------------------------------

* UnnecessaryIntegerInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  It is unnecessary to instantiate Integer objects. Instead just use the literal with the 'I' identifier to force the type, such as 8I or 42i.


* UnnecessaryLongInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  It is unnecessary to instantiate Long objects. Instead just use the literal with the 'L' identifier to force the type, such as 8L or 42L.


* UnnecessaryObjectReferences Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  Violations are triggered when an excessive set of consecutive statements all reference the same variable. This can be
  made more readable by using a with or identity block. By default, 5 references are allowed. You can override this
  property using the maxReferencesAllowed property on the rule.

  These two bits of code produce violations:

-------------------------------------------------------------------------------
    def p1 = new Person()
    p1.firstName = 'Hamlet'
    p1.lastName = "D'Arcy"
    p1.employer = 'Canoo'
    p1.street = 'Kirschgaraten 5'
    p1.city = 'Basel'
    p1.zipCode = '4051'

    def p2 = new Person()
    p2.setFirstName('Hamlet')
    p2.setLastName("D'Arcy")
    p2.setEmployer('Canoo')
    p2.setStreet('Kirschgaraten 5')
    p2.setCity('Basel')
    p2.setZipCode('4051')
-------------------------------------------------------------------------------

However, these two bits of code do not because they use either a <<<with>>> or <<<identity>>> block.
-------------------------------------------------------------------------------
    def p1 = new Person().with {
        firstName = 'Hamlet'
        lastName = "D'Arcy"
        employer = 'Canoo'
        street = 'Kirschgaraten 5'
        city = 'Basel'
        zipCode = '4051'
    }

    def p2 = new Person().identity {
        firstName = 'Hamlet'
        lastName = "D'Arcy"
        employer = 'Canoo'
        street = 'Kirschgaraten 5'
        city = 'Basel'
        zipCode = '4051'
    }
-------------------------------------------------------------------------------


* UnnecessaryOverridingMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  Checks for an overriding method that merely calls the same method defined in a superclass. Remove it.


* UnnecessaryReturnKeyword Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  In Groovy, the <<<return>>> keyword is often optional. If a statement is the last line in a method or
  closure then you do not need to have the <<<return>>> keyword.

