		--------------------------------------------------
					  CodeNarc - Basic Rules
		--------------------------------------------------

Basic Rules  ("<rulesets/basic.xml>")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* BigDecimalInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for calls to the <<<java.math.BigDecimal>>> constructors that take a <<<double>>> value as
  the first parameter. As described in the <<<BigDecimal>>> javadoc, the results from these constructors 
  can be somewhat unpredictable, and their use is generally not recommended. This is because some numbers,
  such as 0.1, cannot be represented exactly as a <<<double>>>.

  For instance, executing <<<println new BigDecimal(0.1)>>> prints out
  <<<0.1000000000000000055511151231257827021181583404541015625>>>.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def b1 = new BigDecimal(0.1)               // violation
    def b2 = new java.math.BigDecimal(23.45d)  // violation
-------------------------------------------------------------------------------


* BooleanMethodReturnsNull Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  Checks for a method with <<<Boolean>>> return type that returns an explicit <<<null>>>. A method that
  returns either <<<Boolean.TRUE>>>, <<<Boolean.FALSE>>> or <<<null>>> is an accident waiting to happen.
  This method can be invoked as though it returned a value of type <<<boolean>>>, and the compiler will
  insert automatic <unboxing> of the <<<Boolean>>> value. If a <<<null>>> value is returned, this will
  result in a <<<NullPointerException>>>.


* CloneableWithoutClone Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for classes that implement the <<<java.lang.Cloneable>>> interface without implementing
  the <<<clone()>>> method.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class BadClass implements Cloneable {
        def someMethod()
    }
-------------------------------------------------------------------------------

* ConfusingTernary Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  In a ternary expression avoid negation in the test. For example, rephrase:
  <<<(x != y) ? diff : same>>> as: <<<(x == y) ? same : diff>>>. Consistent use of this rule makes the code easier to read.
  Also, this resolves trivial ordering problems, such as "does the error case go first?" or "does the common case go first?".

  Example:
-------------------------------------------------------------------------------
    (x != y) ? diff : same      // triggers violation
    (!x) ? diff : same          // triggers violation

    (x == y) ? same : diff      // OK
    (x) ? same : diff      // OK
-------------------------------------------------------------------------------

* CompareToWithoutComparable Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  If you implement a compareTo method then you should also implement the Comparable interface. If you
  don't then you could possibly get an exception if the Groovy == operator is invoked on your object.
  This is an issue fixed in Groovy 1.8 but present in previous versions.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class BadClass {
        int compareTo(Object o) { ... }
    }
-------------------------------------------------------------------------------



* ConstantIfExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for <if> statements with a constant value for the <if> boolean expression, such as
  <<<true>>>, <<<false>>>, <<<null>>>, or a literal constant value. These <if> statements
  can be simplified or avoided altogether. Examples of violations include:

-------------------------------------------------------------------------------
    if (true) { .. }
    if (false) { .. }
    if (Boolean.TRUE) { .. }
    if (Boolean.FALSE) { .. }
    if (null) { .. }
    if (0) { .. }
    if (99.7) { .. }
    if ("") { .. }
    if ("abc") { .. }
    if ([:]) { .. }
    if ([a:123, b:456]) { .. }
    if ([a, b, c]) { .. }
-------------------------------------------------------------------------------


* ConstantTernaryExpression Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for ternary expressions with a constant value for the boolean expression, such as
 <<<true>>>, <<<false>>>, <<<null>>>, or a literal constant value. Examples of violations include:

-------------------------------------------------------------------------------
    true ? x : y
    false ? x : y
    Boolean.TRUE ? x : y
    Boolean.FALSE ? x : y
    null ? x : y
    0 ? x : y
    99.7 ? x : y
    "" ? x : y
    "abc" ? x : y
    [:] ? x : y
    [a:123, b:456] ? x : y
    [a, b, c] ? x : y
-------------------------------------------------------------------------------

 The rule also checks for the same types of constant values for the boolean expressions within the "short"
 ternary expressions, also known as the "Elvis" operator, e.g.:

-------------------------------------------------------------------------------
    true ?: y
    null ?: y
    99.7 ?: y
    "abc" ?: y
    [:] ?: y
    [a, b, c] ?: y
-------------------------------------------------------------------------------


* DeadCode Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  Dead code appears after a <<<return>>> statement or an exception is thrown. If code appears after one of these
  statements then it will never be executed and can be safely deleted.


* DoubleNegative Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  There is no point in using a double negative, it is always positive. For instance <<<!!x>>> can always be
  simplified to <<<x>>>. And <<<!(!x)>>> can as well.


* DuplicateCaseStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  <Since CodeNarc 0.11>

  Check for duplicate <<<case>>> statements in a <<<switch>>> block, such as two equal
  integers or strings. Here are some examples of code that produces violations:

-------------------------------------------------------------------------------
            switch( 0 ) {
                case 1: break;
                case 2: break;
                case 2: break;          // violation
            }

            switch( "test" ) {
                case "$a": break;
                case "$a": break;       // ok; only flags constant values (not GStrings)
                case "ab": break;
                case "ab": break;       // violation
                case "abc": break;
            }
-------------------------------------------------------------------------------


* EmptyCatchBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <catch> blocks. In most cases, exceptions should not be caught and ignored (swallowed).

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        try {
            doSomething
        } catch(MyException e) {
            // should do something here
        }
    }
-------------------------------------------------------------------------------


* EmptyElseBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <else> blocks. Empty <else> blocks are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        if (x==23) {
            println 'ok'
        } else {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptyFinallyBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <finally> blocks. Empty <finally> blocks are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        try {
            doSomething()
        } finally {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptyForStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <for> blocks. Empty <for> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        for (int i=0; i < 23; i++) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptyIfStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <if> statements. Empty <if> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        if (x==23) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptySwitchStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <switch> statements. Empty <switch> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        switch(myVariable) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EmptySynchronizedStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <synchronized> statements. Empty <synchronized> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class MyClass {
        def myMethod() {
            synchronized(lock) {
            }
        }
    }
-------------------------------------------------------------------------------


* EmptyTryBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <try> blocks. Empty <try> blocks are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        try {
            // empty
        } catch(MyException e) {
            e.printStackTrace()
        }
    }
-------------------------------------------------------------------------------


* EmptyWhileStatement Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for empty <while> statements. Empty <while> statements are confusing and serve no purpose.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    def myMethod() {
        while (!stopped) {
            // empty
        }
    }
-------------------------------------------------------------------------------


* EqualsAndHashCode Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks that if either the <<<boolean equals(Object)>>> or the <<<int hashCode()>>> methods
  are overridden within a class, then both must be overridden.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    class MyClass {
        boolean equals(Object object) {
            // do something
        }
    }
-------------------------------------------------------------------------------

  And so does this:

-------------------------------------------------------------------------------
    class MyClass {
        int hashCode() {
            return 0
        }
    }
-------------------------------------------------------------------------------


* ExplicitArrayListInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule checks for the explicit instantiation of an <<<ArrayList>>>. In Groovy, it is best to write
  <<<new ArrayList() as []>>>, which creates the same object.


* ExplicitCallToAndMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<and(Object)>>> method is called directly in code instead of using the <<<&>>>
  operator. A groovier way to express this: <<<a.and(b)>>> is this: <<<a & b>>>. This rule can be
  configured to ignore <<<this.and(Object)>>> using the <ignoreThisReference> property. It defaults to <true>, so
  even <<<and(x)>>> will not trigger a violation. The default is <true> because <<<and>>> appears commonly in Grails
  criteria. 


* ExplicitCallToCompareToMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<compareTo(Object)>>> method is called directly in code instead of using the
  \<\=\>, \>, \>\=, \<, and \<\= operators. A groovier way to express this: <<<a.compareTo(b)>>> is this:
  <<<a \<\=\> b>>>, or using the other operators. Here are some other ways to write groovier code:

-------------------------------------------------------------------------------
    a.compareTo(b) == 0               // can be replaced by: a == b
    a.compareTo(b)                    // can be replaced by: a <=> b
    a.compareTo(b) > 0                // can be replaced by: a > b
    a.compareTo(b) >= 0               // can be replaced by: a >= b
    a.compareTo(b) < 0                // can be replaced by: a < b
    a.compareTo(b) <= 0               // can be replaced by: a <= b
-------------------------------------------------------------------------------
  This rule can be  configured to ignore <<<this.compareTo(Object)>>> using the <ignoreThisReference>
  property. It defaults to <<<false>>>, so even <<<compareTo(x)>>> will trigger a violation.


* ExplicitCallToDivMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<div(Object)>>> method is called directly in code instead of using the
  <<</>>> operator. A groovier way to express this: <<<a.div(b)>>> is this: <<<a / b>>>. This rule can be
  configured to ignore <<<div.xor(Object)>>> using the <ignoreThisReference> property. It defaults to <false>,
  so even <<<div(x)>>> will trigger a violation.


* ExplicitCallToEqualsMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<equals(Object)>>> method is called directly in code instead of using the
  <<<==>>> or <<<!=>>> operator. A groovier way to express this: <<<a.equals(b)>>> is this: <<<a == b>>>
   and a groovier way to express : <<<!a.equals(b)>>> is: <<<a != b>>>. This rule can be
  configured to ignore <<<this.equals(Object)>>> using the <ignoreThisReference> property. It defaults to
  <false>, so even <<<equals(x)>>> will trigger a violation.


* ExplicitCallToGetAtMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<getAt(Object)>>> method is called directly in code instead of using the
  <<<[]>>> index operator. A groovier way to express this: <<<a.getAt(b)>>> is this: <<<a[b]>>>. This rule can be
  configured to ignore <<<this.getAt(Object)>>> using the <ignoreThisReference> property. It defaults to <false>,
  so even <<<getAt(x)>>> will trigger a violation.


* ExplicitCallToLeftShiftMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<leftShift(Object)>>> method is called directly in code instead of using the
  \<\< operator. A groovier way to express this: <<<a.leftShift(b)>>> is this: <<<a \<\< b>>>. This rule can be
  configured to ignore <<<this.leftShift(Object)>>> using the <ignoreThisReference> property. It defaults to
  <false>, so even <<<leftShift(x)>>> will trigger a violation.


* ExplicitCallToMinusMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<minus(Object)>>> method is called directly in code instead of using the
  <<<->>> operator. A groovier way to express this: <<<a.minus(b)>>> is this: <<<a - b>>>. This rule can be
  configured to ignore <<<minus.xor(Object)>>> using the <ignoreThisReference> property. It defaults to
  <false>, so even <<<minus(x)>>> will trigger a violation.


* ExplicitCallToMultiplyMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<multiply(Object)>>> method is called directly in code instead of using the
  <<<*>>> operator. A groovier  way to express this: <<<a.multiply(b)>>> is this: <<<a * b>>>. This rule can be
  configured to ignore <<<this.multiply(Object)>>> using the <ignoreThisReference> property. It defaults to
  <false>, so even <<<multiply(x)>>> will trigger a violation. 


* ExplicitCallToModMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<mod(Object)>>> method is called directly in code instead of using the
  <<<%>>> operator. A groovier way to express this: <<<a.mod(b)>>> is this: <<<a % b>>>. This rule can be
  configured to ignore <<<this.mod(Object)>>> using the <ignoreThisReference> property. It defaults to <false>, so
  even <<<mod(x)>>> will trigger a violation. 


* ExplicitCallToOrMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<or(Object)>>> method is called directly in code instead of using the <<<|>>>
  operator. A groovier way to express this: <<<a.or(b)>>> is this: <<<a | b>>>. This rule can be
  configured to ignore <<<this.or(Object)>>> using the <ignoreThisReference> property. It defaults to <true>, so
  even <<<or(x)>>> will not trigger a violation. This is the default because it is commonly used in Grails criteria. 


* ExplicitCallToPlusMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<plus(Object)>>> method is called directly in code instead of using the
  <<<+>>> operator. A groovier way to express this: <<<a.plus(b)>>> is this: <<<a + b>>>. This rule can be
  configured to ignore <<<this.plus(Object)>>> using the <ignoreThisReference> property. It defaults to <false>, so
  even <<<plus(x)>>> will trigger a violation.


* ExplicitCallToPowerMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<power(Object)>>> method is called directly in code instead of using the
  <<<**>>> operator. A groovier way to express this: <<<a.power(b)>>> is this: <<<a ** b>>>. This rule can be
  configured to ignore <<<this.power(Object)>>> using the <ignoreThisReference> property. It defaults to <false>, so
  even <<<power(x)>>> will trigger a violation.


* ExplicitCallToRightShiftMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<rightShift(Object)>>> method is called directly in code instead of using the
  \>\> operator. A groovier way to express this: <<<a.rightShift(b)>>> is this: <<<a \>\> b>>>. This rule can be
  configured to ignore <<<this.rightShift(Object)>>> using the <ignoreThisReference> property. It defaults to
  <false>, so even <<<rightShift(x)>>> will trigger a violation.


* ExplicitCallToXorMethod Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule detects when the <<<xor(Object)>>> method is called directly in code instead of using the
  <<<^>>> operator. A groovier way to express this: <<<a.xor(b)>>> is this: <<<a ^ b>>>. This rule can be
  configured to ignore <<<this.xor(Object)>>> using the <ignoreThisReference> property. It defaults to <false>, so
  even <<<xor(x)>>> will trigger a violation.

* ExplicitGarbageCollection Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  New in CodeNarc 0.12
  Calls to System.gc(), Runtime.getRuntime().gc(), and System.runFinalization() are not advised. Code should have
  the same behavior whether the garbage collection is disabled using the option -Xdisableexplicitgc or not. Moreover,
  "modern" jvms do a very good job handling garbage collections. If memory usage issues unrelated to memory leaks develop
  within an application, it should be dealt with JVM options rather than within the code itself.


* ExplicitHashMapInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule checks for the explicit instantiation of a <<<HashMap>>>. In Groovy, it is best to write
  <<<new HashMap() as [:]>>>, which creates the same object.


* ExplicitHashSetInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule checks for the explicit instantiation of a <<<HashSet>>>. In Groovy, it is best to write
  <<<new HashSet()>>> as <<<[] as Set>>>, which creates the same object.


* ExplicitLinkedListInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule checks for the explicit instantiation of a <<<LinkedList>>>. In Groovy, it is best to write
  <<<new LinkedList()>>> as <<<[] as Queue>>>, which creates the same object.


* ExplicitStackInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule checks for the explicit instantiation of a <<<Stack>>>. In Groovy, it is best to write
  <<<new Stack()>>> as <<<[] as Stack>>>, which creates the same object.


* ExplicitTreeSetInstantiation Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  This rule checks for the explicit instantiation of a <<<TreeSet>>>. In Groovy, it is best to write
  <<<new TreeSet()>>> as <<<[] as SortedSet>>>, which creates the same object.


* GStringAsMapKey Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  <Since CodeNarc 0.11>

  A GString should not be used as a map key since its <hashcode> is not guaranteed to be stable.
  Consider calling <<<key.toString()>>>.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    Map map = ["${someRef}" : 'invalid' ]       // violation
-------------------------------------------------------------------------------

* InvertedIfElse Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  An inverted <if-else> statement is one in which there is a single <<<if>>> statement with a single
  <<<else>>> branch and the boolean test of the <<<if>>> is negated. For instance <<<if (!x) false else true>>>.
  It is usually clearer to write this as <<<if (x) true else false>>>.


* RemoveAllOnSelf Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  Don't use <<<removeAll>>> to clear a collection. If you want to remove all elements from a
  collection <<<c>>>, use <<<c.clear>>>, not <<<c.removeAll(c)>>>. Calling <<<c.removeAll(c)>>>
  to clear a collection is less clear, susceptible to errors from typos, less efficient and
  for some collections, might throw a <<<ConcurrentModificationException>>>.


* ReturnFromFinallyBlock Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Checks for a return from within a <finally> block. Returning from a <finally> block is confusing and 
  can hide the original exception.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    int myMethod() {
        try {
            doSomething()
            return 0
        } catch(Exception e) {
            return -1
        } finally {
            return 99               // violation
        }
    }
-------------------------------------------------------------------------------


* ReturnsNullInsteadOfEmptyArray Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  If you have a method or closure that returns an array, then when there are no results return a zero-length
  (empty) array rather than <<<null>>>. It is often a better design to return a zero-length array rather than a
  <<<null>>> reference to indicate that there are no results (i.e., an <empty> list of results). This way,
  no explicit check for <<<null>>> is needed by clients of the method.


* ReturnsNullInsteadOfEmptyCollection Rule
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  <Since CodeNarc 0.11>

  If you have a method or closure that returns a collection, then when there are no results return a zero-length
  (empty) collection rather than <<<null>>>. It is often a better design to return a zero-length collection
  rather than a <<<null>>> reference to indicate that there are no results (i.e., an <empty> list of results).
  This way, no explicit check for <<<null>>> is needed by clients of the method.


* SerialVersionUID Rule
~~~~~~~~~~~~~~~~~~~~~~~~

  <Since CodeNarc 0.11>

  A <<serialVersionUID>> is normally intended to be used with Serialization. It needs to be of type
  <<<long>>>, <<<static>>>, and <<<final>>>. Also, it should have a <visibility modifier> such
  as <<<public>>> or <<<private>>>. Providing no modifier creates a <Property> and Groovy generates
  a <getter>, which is probably not intended.


* ThrowExceptionFromFinallyBlock
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Checks for throwing an exception from within a <finally> block. Throwing an exception from a
 <finally> block is confusing and can hide the original exception.

  Here is an example of code that produces a violation:

-------------------------------------------------------------------------------
    int myMethod() {
        try {
            doSomething()
            throw new Exception()
        } finally {
            println 'finally'
            throw new Exception()   // violation
        }
    }
-------------------------------------------------------------------------------


