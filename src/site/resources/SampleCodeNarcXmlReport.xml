<?xml version='1.0'?>
<CodeNarc url='http://www.codenarc.org' version='0.11'><Report timestamp='Nov 12, 2010 9:50:16 PM'/><Project title='Sample Project'><SourceDirectory>samples\src</SourceDirectory></Project><PackageSummary totalFiles='7' filesWithViolations='4' priority1='0' priority2='11' priority3='4'></PackageSummary><Package path='org' totalFiles='7' filesWithViolations='4' priority1='0' priority2='11' priority3='4'></Package><Package path='org/codenarc' totalFiles='7' filesWithViolations='4' priority1='0' priority2='11' priority3='4'></Package><Package path='org/codenarc/sample' totalFiles='7' filesWithViolations='4' priority1='0' priority2='11' priority3='4'></Package><Package path='org/codenarc/sample/domain' totalFiles='2' filesWithViolations='1' priority1='0' priority2='3' priority3='2'><File name='SampleDomain.groovy'><Violation ruleName='EmptyElseBlock' priority='2' lineNumber='24'><SourceLine><![CDATA[else {]]></SourceLine></Violation><Violation ruleName='EmptyIfStatement' priority='2' lineNumber='21'><SourceLine><![CDATA[if (name) {]]></SourceLine></Violation><Violation ruleName='StringInstantiation' priority='2' lineNumber='17'><SourceLine><![CDATA[def title = new String('Sample Domain')]]></SourceLine></Violation><Violation ruleName='ImportFromSamePackage' priority='3' lineNumber='4'><SourceLine><![CDATA[import org.codenarc.sample.domain.OtherDomain]]></SourceLine></Violation><Violation ruleName='UnnecessaryGroovyImport' priority='3' lineNumber='3'><SourceLine><![CDATA[import java.util.Map]]></SourceLine></Violation></File></Package><Package path='org/codenarc/sample/other' totalFiles='1' filesWithViolations='0' priority1='0' priority2='0' priority3='0'></Package><Package path='org/codenarc/sample/service' totalFiles='4' filesWithViolations='3' priority1='0' priority2='8' priority3='2'><File name='NewService.groovy'><Violation ruleName='EmptyForStatement' priority='2' lineNumber='12'><SourceLine><![CDATA[for(int i=0; i < values.size(); i++) {]]></SourceLine></Violation><Violation ruleName='EmptyWhileStatement' priority='2' lineNumber='18'><SourceLine><![CDATA[while (!values.empty) {]]></SourceLine></Violation></File><File name='OtherService.groovy'><Violation ruleName='EmptyFinallyBlock' priority='2' lineNumber='13'><SourceLine><![CDATA[finally {]]></SourceLine></Violation><Violation ruleName='EmptyTryBlock' priority='2' lineNumber='10'><SourceLine><![CDATA[try {]]></SourceLine></Violation><Violation ruleName='ReturnFromFinallyBlock' priority='2' lineNumber='24'><SourceLine><![CDATA[return]]></SourceLine></Violation></File><File name='SampleService.groovy'><Violation ruleName='BooleanInstantiation' priority='2' lineNumber='17'><SourceLine><![CDATA[def shouldRun = new Boolean(true)]]></SourceLine></Violation><Violation ruleName='EmptyCatchBlock' priority='2' lineNumber='20'><SourceLine><![CDATA[} catch(Throwable t) {]]></SourceLine></Violation><Violation ruleName='ThrowExceptionFromFinallyBlock' priority='2' lineNumber='31'><SourceLine><![CDATA[throw new Exception('bad stuff')]]></SourceLine></Violation><Violation ruleName='UnnecessaryGroovyImport' priority='3' lineNumber='3'><SourceLine><![CDATA[import java.util.Map]]></SourceLine></Violation><Violation ruleName='UnusedImport' priority='3' lineNumber='4'><SourceLine><![CDATA[import org.codenarc.sample.domain.SampleDomain]]></SourceLine></Violation></File></Package><Rules><Rule name='BigDecimalInstantiation'><Description><![CDATA[Checks for calls to the BigDecimal constructors that take a double parameter, which may result in an unexpected BigDecimal value.]]></Description></Rule><Rule name='BooleanInstantiation'><Description><![CDATA[Use Boolean.valueOf() for variable values or Boolean.TRUE and Boolean.FALSE for constant values instead of calling the Boolean() constructor directly or calling Boolean.valueOf(true) or Boolean.valueOf(false).]]></Description></Rule><Rule name='BooleanMethodReturnsNull'><Description><![CDATA[Method with Boolean return type returns explicit null. A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.]]></Description></Rule><Rule name='CloneableWithoutClone'><Description><![CDATA[A class that implements java.lang.Cloneable should define a clone() method.]]></Description></Rule><Rule name='ConstantIfExpression'><Description><![CDATA[Checks for if statements with a constant value for the if expression, such as true, false, null, or a literal constant value.]]></Description></Rule><Rule name='ConstantTernaryExpression'><Description><![CDATA[Checks for ternary expressions with a constant value for the boolean expression, such as true, false, null, or a literal constant value.]]></Description></Rule><Rule name='DeadCode'><Description><![CDATA[Dead code appears after a return statement or an exception is thrown. If code appears after one of these statements then it will never be executed and can be safely deleted. ]]></Description></Rule><Rule name='DoubleNegative'><Description><![CDATA[There is no point in using a double negative, it is always positive. For instance !!x can always be simplified to x. And !(!x) can as well.]]></Description></Rule><Rule name='DuplicateCaseStatement'><Description><![CDATA[Check for duplicate case statements in a switch block, such as two equal integers or strings.]]></Description></Rule><Rule name='DuplicateImport'><Description><![CDATA[Duplicate import statements are unnecessary.]]></Description></Rule><Rule name='EmptyCatchBlock'><Description><![CDATA[In most cases, exceptions should not be caught and ignored (swallowed).]]></Description></Rule><Rule name='EmptyElseBlock'><Description><![CDATA[Empty else blocks are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyFinallyBlock'><Description><![CDATA[Empty finally blocks are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyForStatement'><Description><![CDATA[Empty for statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyIfStatement'><Description><![CDATA[Empty if statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptySwitchStatement'><Description><![CDATA[Empty switch statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptySynchronizedStatement'><Description><![CDATA[Empty synchronized statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyTryBlock'><Description><![CDATA[Empty try blocks are confusing and serve no purpose.]]></Description></Rule><Rule name='EmptyWhileStatement'><Description><![CDATA[Empty while statements are confusing and serve no purpose.]]></Description></Rule><Rule name='EqualsAndHashCode'><Description><![CDATA[If either the equals(Object) or the hashCode() methods are overridden within a class, then both must be overridden.]]></Description></Rule><Rule name='ExplicitArrayListInstantiation'><Description><![CDATA[This rule checks for the explicit instantiation of an ArrayList. In Groovy, it is best to write "new ArrayList()" as "[]", which creates the same object.]]></Description></Rule><Rule name='ExplicitCallToAndMethod'><Description><![CDATA[This rule detects when the and(Object) method is called directly in code instead of using the & operator. A groovier way to express this: a.and(b) is this: a & b]]></Description></Rule><Rule name='ExplicitCallToCompareToMethod'><Description><![CDATA[This rule detects when the compareTo(Object) method is called directly in code instead of using the <=>, >, >=, <, and <= operators. A groovier way to express this: a.compareTo(b) is this: a <=> b, or using the other operators.]]></Description></Rule><Rule name='ExplicitCallToDivMethod'><Description><![CDATA[This rule detects when the div(Object) method is called directly in code instead of using the / operator. A groovier way to express this: a.div(b) is this: a / b]]></Description></Rule><Rule name='ExplicitCallToEqualsMethod'><Description><![CDATA[This rule detects when the equals(Object) method is called directly in code instead of using the == or != operator. A groovier way to express this: a.equals(b) is this: a == b and a groovier way to express : !a.equals(b) is : a != b]]></Description></Rule><Rule name='ExplicitCallToGetAtMethod'><Description><![CDATA[This rule detects when the getAt(Object) method is called directly in code instead of using the [] index operator. A groovier way to express this: a.getAt(b) is this: a[b]]]></Description></Rule><Rule name='ExplicitCallToLeftShiftMethod'><Description><![CDATA[This rule detects when the leftShift(Object) method is called directly in code instead of using the << operator. A groovier way to express this: a.leftShift(b) is this: a << b]]></Description></Rule><Rule name='ExplicitCallToMinusMethod'><Description><![CDATA[This rule detects when the minus(Object) method is called directly in code instead of using the - operator. A groovier way to express this: a.minus(b) is this: a - b]]></Description></Rule><Rule name='ExplicitCallToModMethod'><Description><![CDATA[This rule detects when the mod(Object) method is called directly in code instead of using the % operator. A groovier way to express this: a.mod(b) is this: a % b]]></Description></Rule><Rule name='ExplicitCallToMultiplyMethod'><Description><![CDATA[This rule detects when the minus(Object) method is called directly in code instead of using the * operator. A groovier way to express this: a.multiply(b) is this: a * b]]></Description></Rule><Rule name='ExplicitCallToOrMethod'><Description><![CDATA[This rule detects when the or(Object) method is called directly in code instead of using the | operator. A groovier way to express this: a.or(b) is this: a | b]]></Description></Rule><Rule name='ExplicitCallToPlusMethod'><Description><![CDATA[This rule detects when the plus(Object) method is called directly in code instead of using the + operator. A groovier way to express this: a.plus(b) is this: a + b]]></Description></Rule><Rule name='ExplicitCallToPowerMethod'><Description><![CDATA[This rule detects when the power(Object) method is called directly in code instead of using the ** operator. A groovier way to express this: a.power(b) is this: a ** b]]></Description></Rule><Rule name='ExplicitCallToRightShiftMethod'><Description><![CDATA[This rule detects when the rightShift(Object) method is called directly in code instead of using the >> operator. A groovier way to express this: a.rightShift(b) is this: a >> b]]></Description></Rule><Rule name='ExplicitCallToXorMethod'><Description><![CDATA[This rule detects when the xor(Object) method is called directly in code instead of using the ^ operator. A groovier way to express this: a.xor(b) is this: a ^ b]]></Description></Rule><Rule name='ExplicitHashMapInstantiation'><Description><![CDATA[This rule checks for the explicit instantiation of a HashMap. In Groovy, it is best to write "new HashMap()" as "[:]", which creates the same object.]]></Description></Rule><Rule name='ExplicitHashSetInstantiation'><Description><![CDATA[This rule checks for the explicit instantiation of a HashSet. In Groovy, it is best to write "new HashSet()" as "[] as Set", which creates the same object.]]></Description></Rule><Rule name='ExplicitLinkedListInstantiation'><Description><![CDATA[This rule checks for the explicit instantiation of a LinkedList. In Groovy, it is best to write "new LinkedList()" as "[] as Queue", which creates the same object.]]></Description></Rule><Rule name='ExplicitStackInstantiation'><Description><![CDATA[This rule checks for the explicit instantiation of a Stack. In Groovy, it is best to write "new Stack()" as "[] as Stack", which creates the same object.]]></Description></Rule><Rule name='ExplicitTreeSetInstantiation'><Description><![CDATA[This rule checks for the explicit instantiation of a TreeSet. In Groovy, it is best to write "new TreeSet()" as "[] as SortedSet", which creates the same object.]]></Description></Rule><Rule name='GStringAsMapKey'><Description><![CDATA[A GString should not be used as a map key since its hashcode is not guaranteed to be stable. Consider calling key.toString().]]></Description></Rule><Rule name='ImportFromSamePackage'><Description><![CDATA[An import of a class that is within the same package is unnecessary.]]></Description></Rule><Rule name='InvertedIfElse'><Description><![CDATA[An inverted if-else statement is one in which there is a single if statement with a single else branch and the boolean test of the if is negated. For instance "if (!x) false else true". It is usually clearer to write this as "if (x) true else false". ]]></Description></Rule><Rule name='RemoveAllOnSelf'><Description><![CDATA[Don't use removeAll to clear a collection. If you want to remove all elements from a collection c, use c.clear, not c.removeAll(c). Calling c.removeAll(c) to clear a collection is less clear, susceptible to errors from typos, less efficient and for some collections, might throw a ConcurrentModificationException.]]></Description></Rule><Rule name='ReturnFromFinallyBlock'><Description><![CDATA[Returning from a finally block is confusing and can hide the original exception.]]></Description></Rule><Rule name='ReturnsNullInsteadOfEmptyArray'><Description><![CDATA[Consider returning a zero length array rather than null. It is often a better design to return a length zero array rather than a null reference to indicate that there are no results (i.e., an empty list of results). This way, no explicit check for null is needed by clients of the method.]]></Description></Rule><Rule name='ReturnsNullInsteadOfEmptyCollection'><Description><![CDATA[Consider returning a zero length collection rather than null. It is often a better design to return a length zero collection rather than a null reference to indicate that there are no results (i.e., an empty list of results). This way, no explicit check for null is needed by clients of the method.]]></Description></Rule><Rule name='SerialVersionUID'><Description><![CDATA[A serialVersionUID is normally intended to be used with Serialization. It needs to be of type long, static, and final. Also, it should have a visibility modifier such as public or private. Providing no modifier creates a Property and Groovy generates a getter, which is probably not intended.]]></Description></Rule><Rule name='StringInstantiation'><Description><![CDATA[Use a String literal (e.g., "...") instead of calling the corresponding String constructor (new String("..")) directly.]]></Description></Rule><Rule name='ThrowExceptionFromFinallyBlock'><Description><![CDATA[Throwing an exception from a finally block is confusing and can hide the original exception.]]></Description></Rule><Rule name='UnnecessaryGroovyImport'><Description><![CDATA[A Groovy file does not need to include an import for classes from java.lang, java.util, java.io, java.net, groovy.lang and groovy.util, as well as the classes java.math.BigDecimal and java.math.BigInteger.]]></Description></Rule><Rule name='UnusedImport'><Description><![CDATA[Imports for a class that is never referenced within the source file is unnecessary.]]></Description></Rule></Rules></CodeNarc>